#!/usr/bin/env python3
"""Spectral parity / RS-consistency test for CMB alm coefficients.

Rotation-invariant "multiplex" test:
  1) Obtain a_{\ell m} coefficients (TT, and optionally EE/BB via Q/U).
  2) Define an ordering k(\ell,m) = \ell^2 + \ell + m (shell-by-shell).
  3) Quantize each coefficient to an 8-bit symbol (phase quantization).
  4) Scan frames of length 255 symbols and compute:
     - Hamming(8,4) validity rate (quick screening)
     - RS(255,201) syndrome score E = count_{j=1..54}[S_j==0]
  5) Compute p-values via Monte Carlo nulls that preserve C_\ell.

Inputs
------
You can pass either maps (HEALPix FITS) or alm (FITS) files.
For polarization, pass Q/U maps or precomputed almE/almB.

Null models
-----------
N1: Phase randomization per \ell (preserves |a_{\ell m}| hence C_\ell).

Notes
-----
- This is a forensic "consistency" test, not a proof of any model.
- A null result does not invalidate UBT Layer-1; it only constrains this
  specific Layer-2 encoding hypothesis.
"""

from __future__ import annotations

import argparse
import math
import os
import random
import sys
import time
from dataclasses import dataclass
from typing import Dict, Iterable, List, Optional, Sequence, Tuple

import numpy as np

try:
    from tqdm import tqdm
except Exception:  # pragma: no cover
    tqdm = None

try:
    import healpy as hp
except Exception as e:  # pragma: no cover
    hp = None

from .rs_syndrome import RSParams, syndrome_zero_count


# RSParams API compatibility: some versions accept nsym, others derive it.
# Our local rs_syndrome.RSParams accepts (n,k,nsym), but keep this robust.
def _make_rs_params(RSParams, n=255, k=201, nsym=54):
    try:
        import inspect
        sig = inspect.signature(RSParams)
        params = sig.parameters
        if 'nsym' in params:
            return RSParams(n=n, k=k, nsym=nsym)
        if 'parity' in params:
            return RSParams(n=n, k=k, parity=nsym)
        if 'npar' in params:
            return RSParams(n=n, k=k, npar=nsym)
        return RSParams(n=n, k=k)
    except Exception:
        try:
            return RSParams(n, k, nsym)
        except Exception:
            return RSParams(n, k)


class _Progress:
    """Single-line progress reporting with optional tqdm support.

    Uses tqdm if available; otherwise writes a single updating line to stderr.
    Designed to avoid spamming many lines in long Monte Carlo runs.
    """

    def __init__(self, enabled: bool, total: int, desc: str, unit: str = 'it'):
        self.enabled = bool(enabled)
        self.total = int(total)
        self.desc = desc
        self.unit = unit
        self._t0 = time.time()
        self._i = 0
        self._pbar = None
        if self.enabled and tqdm is not None:
            self._pbar = tqdm(total=self.total, desc=self.desc, unit=self.unit, dynamic_ncols=True)

    def update(self, n: int = 1, **postfix):
        if not self.enabled:
            return
        self._i += n
        if self._pbar is not None:
            self._pbar.update(n)
            if postfix:
                # Keep postfix compact; tqdm renders it on the same line.
                self._pbar.set_postfix(**{k: v for k, v in postfix.items() if v is not None})
            return

        # Fallback: single-line status (carriage-return overwrite).
        elapsed = time.time() - self._t0
        rate = (self._i / elapsed) if elapsed > 0 else 0.0
        eta = ((self.total - self._i) / rate) if rate > 0 else float('inf')
        tail = '  '.join([f"{k}={v}" for k, v in postfix.items() if v is not None])
        msg = f"{self.desc}: {self._i}/{self.total} {self.unit}  {rate:.2f}/{self.unit}/s  ETA {eta:.0f}s"
        if tail:
            msg += '  |  ' + tail
        sys.stderr.write('\r' + msg[:220].ljust(220))
        sys.stderr.flush()

    def close(self):
        if not self.enabled:
            return
        if self._pbar is not None:
            self._pbar.close()
            return
        sys.stderr.write('\n')
        sys.stderr.flush()


@dataclass
class Symbols:
    name: str
    symbols: np.ndarray  # uint8


def _require_healpy() -> None:
    if hp is None:
        raise RuntimeError(
            "healpy is required to load maps/alm. Install via: pip install healpy"
        )


def k_index(ell: int, m: int) -> int:
    """k(ell,m) = ell^2 + ell + m."""
    return ell * ell + ell + m


DEFAULT_LMIN = 2


def quantize_phase_to_u8(z: complex) -> int:
    """Map complex phase arg(z) to 0..255."""
    if z == 0:
        return 0
    phi = math.atan2(z.imag, z.real)
    if phi < 0:
        phi += 2 * math.pi
    return int((256.0 * phi) / (2 * math.pi)) & 0xFF


def hamming_8_4_is_valid(byte: int) -> bool:
    """Check if an 8-bit value is a valid extended Hamming(8,4) codeword.

    Bit positions (1-indexed): 1,2,4 are parity; 8 is overall parity.
    Data bits at 3,5,6,7.

    This yields 16 valid codewords out of 256 (expected rate 1/16 for random bytes).
    """
    b = [(byte >> i) & 1 for i in range(8)]  # b[0] is LSB
    # Map to positions 1..8 where position 1 is LSB
    p1 = b[0]
    p2 = b[1]
    d1 = b[2]
    p4 = b[3]
    d2 = b[4]
    d3 = b[5]
    d4 = b[6]
    p8 = b[7]

    c1 = (d1 ^ d2 ^ d4) == p1
    c2 = (d1 ^ d3 ^ d4) == p2
    c4 = (d2 ^ d3 ^ d4) == p4
    overall = (p1 ^ p2 ^ d1 ^ p4 ^ d2 ^ d3 ^ d4) == p8
    return bool(c1 and c2 and c4 and overall)


def hamming_valid_rate(symbols: np.ndarray) -> float:
    if symbols.size == 0:
        return float('nan')
    ok = 0
    for x in symbols.tolist():
        if hamming_8_4_is_valid(int(x)):
            ok += 1
    return ok / float(symbols.size)


def load_alm_from_map(map_path: str, lmax: int) -> np.ndarray:
    _require_healpy()

    # healpy>=1.15 deprecates "verbose"; keep compatibility.
    m = hp.read_map(map_path, field=0)
    alm = hp.map2alm(m, lmax=lmax, pol=False, iter=3)
    return alm


def load_almE_B_from_qu_maps(q_path: str, u_path: str, lmax: int) -> Tuple[np.ndarray, np.ndarray]:
    _require_healpy()
    q = hp.read_map(q_path, field=0)
    u = hp.read_map(u_path, field=0)
    # spin-2 transform
    almE, almB = hp.map2alm_spin([q, u], spin=2, lmax=lmax, iter=3)
    return almE, almB


def load_alm_fits(path: str) -> np.ndarray:
    _require_healpy()
    return hp.read_alm(path)


def build_symbol_stream_from_alm(alm: np.ndarray, lmax: int, name: str, lmin: int = DEFAULT_LMIN) -> Symbols:
    """Build uint8 symbol stream using phase quantization, for all m in [-ell,ell].

    healpy stores only m>=0. For real fields, negative m are obtained by:
      a_{l,-m} = (-1)^m * conj(a_{l,m})
    """
    _require_healpy()
    sym = np.zeros(((lmax + 1) * (lmax + 1)), dtype=np.uint8)  # total modes up to lmax

    for ell in range(lmin, lmax + 1):
        # m=0
        a0 = hp.Alm.getidx(lmax, ell, 0)
        sym[k_index(ell, 0)] = quantize_phase_to_u8(complex(alm[a0]))
        for m in range(1, ell + 1):
            idx = hp.Alm.getidx(lmax, ell, m)
            a = complex(alm[idx])
            sym[k_index(ell, m)] = quantize_phase_to_u8(a)
            aneg = ((-1) ** m) * np.conj(a)
            sym[k_index(ell, -m)] = quantize_phase_to_u8(complex(aneg))

    return Symbols(name=name, symbols=sym)


def phase_randomize_per_ell(
    alm: np.ndarray,
    lmax: int,
    rng: np.random.Generator,
    lmin: int = DEFAULT_LMIN,
) -> np.ndarray:
    """Null model N1: randomize phases within each ell while preserving amplitudes."""
    _require_healpy()
    out = np.array(alm, copy=True)
    for ell in range(lmin, lmax + 1):
        # m=0 real mode: keep as is (or random sign); keep as is for safety.
        for m in range(1, ell + 1):
            idx = hp.Alm.getidx(lmax, ell, m)
            r = abs(out[idx])
            phi = rng.uniform(0.0, 2 * math.pi)
            out[idx] = r * (math.cos(phi) + 1j * math.sin(phi))
    return out


def windowed(seq: np.ndarray, n: int, step: int) -> Iterable[np.ndarray]:
    for start in range(0, max(0, seq.size - n + 1), step):
        yield seq[start : start + n]


@dataclass
class TestResult:
    name: str
    hamming_rate: float
    rs_mean_zero_syndromes: float
    rs_tail_rate: float


def compute_scores(
    symbols: np.ndarray,
    rs_params: RSParams,
    frame: int = 255,
    step: int = 255,
    tail_k: int = 8,
    max_frames: Optional[int] = None,
    rng: Optional[np.random.Generator] = None,
) -> Tuple[float, float]:
    """Return (mean_zero_count, tail_rate) for RS syndrome zeros.

    Performance note
    ----------------
    Scanning a ~1M symbol stream with step=1 yields ~1M frames; doing that for
    hundreds of Monte Carlo iterations is prohibitively slow.

    Use either:
      - a larger --step (default 255 = non-overlapping frames), and/or
      - --max-frames with --seed to sample a fixed subset of windows.
    """
    counts: List[int] = []

    if max_frames is not None and max_frames > 0:
        if rng is None:
            max_start = max(0, symbols.size - frame)
        if max_start <= 0:
            return float('nan'), float('nan')
        # Sample window starts; align to "step" grid for determinism.
        grid = np.arange(0, max_start + 1, step, dtype=np.int64)
        if grid.size == 0:
            return float('nan'), float('nan')
        choose = min(int(max_frames), int(grid.size))
        starts = rng.choice(grid, size=choose, replace=False)
        for s in starts.tolist():
            w = symbols[s : s + frame]
            counts.append(syndrome_zero_count(w.tolist(), rs_params))
    else:
        for w in windowed(symbols, frame, step):
            counts.append(syndrome_zero_count(w.tolist(), rs_params))
    if not counts:
        return float('nan'), float('nan')
    arr = np.array(counts, dtype=np.float64)
    mean = float(arr.mean())
    tail = float((arr >= tail_k).mean())
    return mean, tail


def run_test(symbols: Symbols, rs_params: RSParams, frame: int, step: int, tail_k: int) -> TestResult:
    ham = hamming_valid_rate(symbols.symbols)
    rs_mean, rs_tail = compute_scores(symbols.symbols, rs_params, frame=frame, step=step, tail_k=tail_k)
    return TestResult(symbols.name, ham, rs_mean, rs_tail)


def monte_carlo_pvalue(obs: float, null_values: List[float]) -> float:
    if not null_values:
        return float('nan')
    ge = sum(1 for v in null_values if v >= obs)
    return (1.0 + ge) / (1.0 + len(null_values))


def main(argv=None) -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument('--lmin', type=int, default=DEFAULT_LMIN, help='minimum ell to include (default: 2)')
    ap.add_argument('--lmax', type=int, default=1024)
    ap.add_argument('--tt-map', type=str, default=None, help='HEALPix FITS map for temperature')
    ap.add_argument('--tt-alm', type=str, default=None, help='FITS alm for temperature')
    ap.add_argument('--q-map', type=str, default=None, help='HEALPix FITS Q map')
    ap.add_argument('--u-map', type=str, default=None, help='HEALPix FITS U map')
    ap.add_argument('--e-alm', type=str, default=None, help='FITS alm for E')
    ap.add_argument('--b-alm', type=str, default=None, help='FITS alm for B')
    ap.add_argument('--mc', type=int, default=50, help='Monte Carlo iterations for null N1')
    ap.add_argument('--frame', type=int, default=255)
    ap.add_argument('--step', type=int, default=255, help='window step (default 255 = non-overlapping)')
    ap.add_argument('--max-frames', type=int, default=4096, help='limit number of windows per run (sampled). 0 disables')
    ap.add_argument('--tail-k', type=int, default=8, help='tail threshold on zero-syndrome count')
    ap.add_argument('--seed', type=int, default=12345)
    ap.add_argument('--progress', dest='progress', action='store_true', help='enable progress display (default: on if TTY)')
    ap.add_argument('--no-progress', dest='progress', action='store_false', help='disable progress display')

    ap.set_defaults(progress=sys.stderr.isatty())

    args = ap.parse_args(argv)


    # RS parameters and RNG
    rs_params = _make_rs_params(RSParams, n=255, k=201, nsym=54)
    rng = np.random.default_rng(args.seed)
    _require_healpy()

    # Load TT
    tt_alm = None
    if args.tt_alm:
        tt_alm = load_alm_fits(args.tt_alm)
    elif args.tt_map:
        tt_alm = load_alm_from_map(args.tt_map, lmax=args.lmax)

    if tt_alm is None:
        raise SystemExit('Provide --tt-map or --tt-alm')

    symbols_all: List[Tuple[str, np.ndarray, np.ndarray]] = []  # (label, alm, symbols)
    tt_sym = build_symbol_stream_from_alm(tt_alm, args.lmax, 'TT', lmin=args.lmin)
    symbols_all.append(('TT', tt_alm, tt_sym.symbols))

    # Load polarization
    if args.e_alm and args.b_alm:
        e_alm = load_alm_fits(args.e_alm)
        b_alm = load_alm_fits(args.b_alm)
        e_sym = build_symbol_stream_from_alm(e_alm, args.lmax, 'EE', lmin=args.lmin)
        b_sym = build_symbol_stream_from_alm(b_alm, args.lmax, 'BB', lmin=args.lmin)
        symbols_all.append(('EE', e_alm, e_sym.symbols))
        symbols_all.append(('BB', b_alm, b_sym.symbols))
    elif args.q_map and args.u_map:
        e_alm, b_alm = load_almE_B_from_qu_maps(args.q_map, args.u_map, lmax=args.lmax)
        e_sym = build_symbol_stream_from_alm(e_alm, args.lmax, 'EE', lmin=args.lmin)
        b_sym = build_symbol_stream_from_alm(b_alm, args.lmax, 'BB', lmin=args.lmin)
        symbols_all.append(('EE', e_alm, e_sym.symbols))
        symbols_all.append(('BB', b_alm, b_sym.symbols))

    print('=== Observed scores ===', flush=True)
    observed: Dict[str, TestResult] = {}
    for label, alm, sym in symbols_all:
        tr = run_test(Symbols(label, sym), rs_params, frame=args.frame, step=args.step, tail_k=args.tail_k)
        observed[label] = tr
        print(f'{label}: hamming_rate={tr.hamming_rate:.6f}  rs_mean_zero={tr.rs_mean_zero_syndromes:.3f}  rs_tail_rate(>={args.tail_k})={tr.rs_tail_rate:.6f}')

    # Monte Carlo null
    print('\n=== Monte Carlo (phase randomization per ell) ===', flush=True)
    for label, alm, sym in symbols_all:
        null_means: List[float] = []
        null_tails: List[float] = []
        obs_mean = observed[label].rs_mean_zero_syndromes
        obs_tail = observed[label].rs_tail_rate

        ge_mean = 0
        ge_tail = 0
        mc_prog = _Progress(args.progress, total=args.mc, desc=f'{label} MC', unit='mc')
        for i_mc in range(args.mc):
            a_null = phase_randomize_per_ell(alm, args.lmax, rng, lmin=args.lmin)
            s_null = build_symbol_stream_from_alm(a_null, args.lmax, name=label, lmin=args.lmin).symbols
            mf = None if args.max_frames == 0 else args.max_frames
            mean, tail = compute_scores(
                s_null,
                rs_params,
                frame=args.frame,
                step=args.step,
                tail_k=args.tail_k,
                max_frames=mf,
                rng=rng,
            )
            null_means.append(mean)
            null_tails.append(tail)

            # Running p-value estimate (one-sided, >= observed)
            if mean >= obs_mean:
                ge_mean += 1
            if tail >= obs_tail:
                ge_tail += 1

            # Update progress occasionally to reduce overhead.
            postfix = None
            if (i_mc + 1) % 5 == 0 or (i_mc + 1) == args.mc:
                p_est_mean = (1.0 + ge_mean) / (1.0 + (i_mc + 1))
                p_est_tail = (1.0 + ge_tail) / (1.0 + (i_mc + 1))
                postfix = {
                    'p_mean': f'{p_est_mean:.4g}',
                    'p_tail': f'{p_est_tail:.4g}',
                }

            if postfix:
                mc_prog.update(1, **postfix)
            else:
                mc_prog.update(1)

        mc_prog.close()

        p_mean = monte_carlo_pvalue(observed[label].rs_mean_zero_syndromes, null_means)
        p_tail = monte_carlo_pvalue(observed[label].rs_tail_rate, null_tails)

        print(f'{label}: p(rs_mean_zero)={p_mean:.4g}  p(rs_tail_rate)={p_tail:.4g}  (mc={args.mc})')

    return 0


if __name__ == '__main__':
    raise SystemExit(main())
