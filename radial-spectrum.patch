rm -f radial-spectrum.patch

cat > radial-spectrum.patch <<'EOF'
diff --git a/forensic_fingerprint/tools/cmb_fft2d_scan.py b/forensic_fingerprint/tools/cmb_fft2d_scan.py
--- a/forensic_fingerprint/tools/cmb_fft2d_scan.py
+++ b/forensic_fingerprint/tools/cmb_fft2d_scan.py
@@ -38,7 +38,7 @@
 import csv
 import math
 import os
 from dataclasses import dataclass
-from typing import Dict, Iterable, List, Optional, Sequence, Tuple
+from typing import Any, Dict, Iterable, List, Optional, Sequence, Tuple
 
 import healpy as hp
 import numpy as np
 
@@ -55,6 +55,41 @@ def _ensure_dir_for(path: Optional[str]) -> None:
     d = os.path.dirname(path)
     if d:
         os.makedirs(d, exist_ok=True)
+
+def _write_radial_dump_csv(
+    path: str,
+    channel: str,
+    meta: Dict[str, Any],
+    obs_spec: np.ndarray,
+    mc_mean: Optional[np.ndarray] = None,
+    mc_std: Optional[np.ndarray] = None,
+    z: Optional[np.ndarray] = None,
+    p_tail: Optional[np.ndarray] = None,
+) -> None:
+    """Write full radial spectrum (and optional MC summary stats) to CSV."""
+    _ensure_dir_for(path)
+    with open(path, "w", newline="") as f:
+        w = csv.writer(f)
+        w.writerow([
+            "channel","nside_out","nlat","nlon","lat_cut_deg","field","window2d","radial","null","mc","seed",
+            "k","obs_psd","mc_mean","mc_std","z","p_tail"
+        ])
+        kmax_eff = len(obs_spec) - 1
+        for k in range(kmax_eff + 1):
+            w.writerow([
+                channel,
+                meta["nside_out"], meta["nlat"], meta["nlon"], meta["lat_cut_deg"],
+                meta["field"], meta["window2d"], meta["radial"], meta["null"], meta["mc"], meta["seed"],
+                k,
+                float(obs_spec[k]) if k < len(obs_spec) else float("nan"),
+                float(mc_mean[k]) if mc_mean is not None and k < len(mc_mean) else float("nan"),
+                float(mc_std[k]) if mc_std is not None and k < len(mc_std) else float("nan"),
+                float(z[k]) if z is not None and k < len(z) else float("nan"),
+                float(p_tail[k]) if p_tail is not None and k < len(p_tail) else float("nan"),
+            ])
 
 def _map2alm_spin_compat(qu_maps, spin: int, lmax: int):
     # Healpy signature differences across versions; try a few combos.
@@ -295,6 +330,90 @@ def _welch_targets(img: np.ndarray,
         out[t.k] = float(spec[t.k]) if 0 <= t.k < len(spec) else float("nan")
     return out
+
+def _welch_spectrum(
+    img: np.ndarray,
+    window2d: str,
+    radial: bool,
+    wx: int, wy: int,
+    sx: int, sy: int,
+    kmax_out: Optional[int] = None,
+) -> np.ndarray:
+    """Welch-style averaged *full* spectrum (radial only).
+
+    Uses the same trojÄlenka scaling + robust radial binning as _welch_targets,
+    but returns the entire radial spectrum array.
+    """
+    if not radial:
+        raise ValueError("_welch_spectrum currently supports radial=True only.")
+    nlat, nlon = img.shape
+    kmax = int(math.floor(math.sqrt((nlon//2)**2 + (nlat//2)**2)))
+    if kmax_out is not None:
+        kmax = min(kmax, int(kmax_out))
+    acc = np.zeros(kmax + 1, dtype=float)
+    cnt = np.zeros_like(acc)
+
+    w2 = _window_2d(window2d, wy, wx, normalize_rms=True)
+
+    ky = np.fft.fftfreq(wy)
+    kx = np.fft.fftfreq(wx)
+    ky_idx = np.where(ky >= 0)[0]
+    kx_idx = np.where(kx >= 0)[0]
+
+    for y0 in range(0, nlat - wy + 1, sy):
+        for x0 in range(0, nlon - wx + 1, sx):
+            patch = img[y0:y0+wy, x0:x0+wx]
+            patch = patch - float(np.mean(patch))
+            pw = patch * w2
+            P, _, _ = _fft2_psd(pw)
+
+            for iy in ky_idx:
+                jy = int(round(abs(ky[iy]) * wy))
+                kyg = int(round(jy * (nlat / wy)))
+                if kyg > nlat//2:
+                    continue
+                for ix in kx_idx:
+                    jx = int(round(abs(kx[ix]) * wx))
+                    kxg = int(round(jx * (nlon / wx)))
+                    if kxg > nlon//2:
+                        continue
+                    val = float(P[iy, ix])
+                    kgf = math.sqrt(kxg * kxg + kyg * kyg)
+                    kg0 = int(math.floor(kgf))
+                    kg1 = kg0 + 1
+                    w1 = kgf - kg0
+                    w0 = 1.0 - w1
+
+                    if 0 <= kg0 <= kmax:
+                        acc[kg0] += w0 * val
+                        cnt[kg0] += w0
+                    if 0 <= kg1 <= kmax:
+                        acc[kg1] += w1 * val
+                        cnt[kg1] += w1
+
+    spec = np.full_like(acc, np.nan, dtype=float)
+    np.divide(acc, cnt, out=spec, where=cnt > 0)
+    return spec
 
 def main() -> None:
     ap = argparse.ArgumentParser()
@@ -324,6 +443,8 @@ def main() -> None:
 
     ap.add_argument("--report-csv", help="Write per-target results to CSV")
     ap.add_argument("--plot-png", help="Write diagnostic plot PNG (requires matplotlib)")
+    ap.add_argument("--dump-radial-csv", default="", help="Write full radial spectrum to CSV (adds MC mean/std/Z/p_tail when --mc>0)")
+    ap.add_argument("--kmax", type=int, default=None, help="Optional max k for --dump-radial-csv (speeds up MC)")
 
     args = ap.parse_args()
@@ -441,6 +562,24 @@ def main() -> None:
         if args.radial:
             k_bins, psd_r = _radial_average(psd, ky, kx)
             obs_global = {t.k: float(psd_r[t.k]) if t.k < len(psd_r) else float("nan") for t in targets}
         else:
             # Use axis-aligned (ky=0, kx=k) bins (positive kx only)
             ky0 = int(np.where(ky == 0)[0][0]) if np.any(ky == 0) else 0
             obs_global = {t.k: float(psd[ky0, t.k]) if 0 <= t.k < psd.shape[1] else float("nan") for t in targets}
+
+        # First-filter: compute full observed radial spectrum if requested
+        obs_spec: Optional[np.ndarray] = None
+        if args.dump_radial_csv and args.radial:
+            kmax_out = args.kmax
+            if obs_welch is not None and wxwy:
+                obs_spec = _welch_spectrum(img, args.window2d, True, wx=wx, wy=wy, sx=sx, sy=sy, kmax_out=kmax_out)  # type: ignore[arg-type]
+            else:
+                if kmax_out is not None and kmax_out >= 0 and kmax_out < len(psd_r) - 1:
+                    obs_spec = psd_r[: kmax_out + 1]
+                else:
+                    obs_spec = psd_r
 
         obs = obs_welch or obs_global
 
@@ -449,6 +594,14 @@ def main() -> None:
 
         # Monte Carlo p-values
         p_mc: Dict[int, float] = {t.k: float("nan") for t in targets}
+        # Full-spectrum MC summary (mean/std/Z/p_tail) for first filter
+        mc_mean = mc_std = z = p_tail = None
+        mean = m2 = ge = None
+        n_mc = 0
+        if args.dump_radial_csv and args.radial and obs_spec is not None and args.mc > 0:
+            mean = np.zeros_like(obs_spec, dtype=float)
+            m2 = np.zeros_like(obs_spec, dtype=float)
+            ge = np.zeros_like(obs_spec, dtype=float)
         if args.mc > 0:
             mc_vals = {t.k: [] for t in targets}
             for i in range(1, args.mc + 1):
@@ -463,6 +622,21 @@ def main() -> None:
                 img_null = img_null - np.mean(img_null)
                 if obs_welch is not None:
                     # Welch mode: evaluate targets via the same sliding-window estimator.
                     vals_n = _welch_targets(img_null, targets, args.window2d, args.radial, wx=wx, wy=wy, sx=sx, sy=sy)
                     for t in targets:
                         mc_vals[t.k].append(float(vals_n[t.k]))
+                    if args.dump_radial_csv and args.radial and obs_spec is not None and mean is not None and ge is not None and m2 is not None:
+                        spec_n = _welch_spectrum(img_null, args.window2d, True, wx=wx, wy=wy, sx=sx, sy=sy, kmax_out=len(obs_spec)-1)  # type: ignore[arg-type]
+                        n_mc += 1
+                        delta = spec_n - mean
+                        mean += delta / n_mc
+                        delta2 = spec_n - mean
+                        m2 += delta * delta2
+                        ge += (spec_n >= obs_spec).astype(float)
                 else:
                     imgw_null = img_null * w2
                     psd_n, ky_n, kx_n = _fft2_psd(imgw_null)
 
                     if args.radial:
                         _, psd_rn = _radial_average(psd_n, ky_n, kx_n, kmax=len(k_bins)-1)
                         for t in targets:
                             if t.k < len(psd_rn):
                                 mc_vals[t.k].append(float(psd_rn[t.k]))
+                        if args.dump_radial_csv and args.radial and obs_spec is not None and mean is not None and ge is not None and m2 is not None:
+                            psd_rn = psd_rn[: len(obs_spec)]
+                            n_mc += 1
+                            delta = psd_rn - mean
+                            mean += delta / n_mc
+                            delta2 = psd_rn - mean
+                            m2 += delta * delta2
+                            ge += (psd_rn >= obs_spec).astype(float)
                     else:
                         ky0 = int(np.where(ky_n == 0)[0][0]) if np.any(ky_n == 0) else 0
                         for t in targets:
@@ -488,6 +662,14 @@ def main() -> None:
                 vals = np.asarray(mc_vals[t.k], dtype=float)
                 if len(vals) > 0 and np.isfinite(obs[t.k]):
                     p_mc[t.k] = float(np.mean(vals >= obs[t.k]))
+
+            if args.dump_radial_csv and args.radial and obs_spec is not None and mean is not None and m2 is not None and ge is not None and n_mc > 1:
+                mc_mean = mean
+                mc_std = np.sqrt(m2 / (n_mc - 1))
+                z = np.full_like(obs_spec, np.nan, dtype=float)
+                np.divide(obs_spec - mc_mean, mc_std, out=z, where=mc_std > 0)
+                p_tail = ge / float(n_mc)
 
             print("\n=== MC p-values (one-sided: PSD >= observed) ===")
             for t in targets:
                 print(f"{ch} k={t.k} p_mc={p_mc[t.k]:.6g}")
@@ -596,6 +778,24 @@ def main() -> None:
             plt.close(fig)
             print(f"[info] wrote PNG: {out_png}")
+
+        # Dump full radial spectrum CSV (first filter)
+        if args.dump_radial_csv and args.radial and obs_spec is not None:
+            meta = dict(
+                nside_out=args.nside_out,
+                nlat=args.nlat,
+                nlon=args.nlon,
+                lat_cut_deg=args.lat_cut,
+                field=args.field,
+                window2d=args.window2d,
+                radial=True,
+                null=args.null if args.mc > 0 else "",
+                mc=int(args.mc),
+                seed=int(args.seed),
+            )
+            out_csv = args.dump_radial_csv
+            if len(ch_list) > 1:
+                base, ext = os.path.splitext(out_csv)
+                out_csv = f"{base}_{ch}{ext}"
+            _write_radial_dump_csv(out_csv, ch, meta, obs_spec, mc_mean, mc_std, z, p_tail)
+            print(f"[info] wrote radial dump CSV: {out_csv}")
EOF

