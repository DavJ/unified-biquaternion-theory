--- a/forensic_fingerprint/tools/cmb_fft2d_scan.py
+++ b/forensic_fingerprint/tools/cmb_fft2d_scan.py
@@ -261,16 +261,32 @@
                         continue
                     val = float(P[iy, ix])
                     if radial:
-                        kg = int(round(math.sqrt(kxg*kxg + kyg*kyg)))
-                        if kg <= kmax:
-                            acc[kg] += val
-                            cnt[kg] += 1
+                        # Robust radial binning:
+                        # The previous implementation used a hard integer bin via round(|k|).
+                        # For some (grid, window) combinations this can leave certain integer
+                        # radii completely empty (cnt==0), producing NaNs for those targets.
+                        # Distribute power linearly between the two nearest integer bins.
+                        kgf = math.sqrt(kxg * kxg + kyg * kyg)
+                        kg0 = int(math.floor(kgf))
+                        kg1 = kg0 + 1
+                        w1 = kgf - kg0
+                        w0 = 1.0 - w1
+
+                        if 0 <= kg0 <= kmax:
+                            acc[kg0] += w0 * val
+                            cnt[kg0] += w0
+                        if 0 <= kg1 <= kmax:
+                            acc[kg1] += w1 * val
+                            cnt[kg1] += w1
                     else:
                         if kyg == 0:
                             acc[kxg] += val
                             cnt[kxg] += 1
 
-    spec = np.where(cnt > 0, acc / cnt, np.nan)
+    # Avoid RuntimeWarning: np.where evaluates both branches eagerly.
+    # Use np.divide with a mask so division is only performed where cnt>0.
+    spec = np.full_like(acc, np.nan, dtype=float)
+    np.divide(acc, cnt, out=spec, where=cnt > 0)
     out: Dict[int, float] = {}
     for t in targets:
         out[t.k] = float(spec[t.k]) if 0 <= t.k < len(spec) else float("nan")

